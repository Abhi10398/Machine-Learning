# k-means

def K_means_clustering(data,K,itr,eps):
  # random initialization of clusters
  # write your code here
  def random_points(data,K):
    return np.random.choice(len(data),K)
  init=random_points(data,K)
  center=[]
  for i in init:
    center.append(data[i])
  center=np.array(center)
  #print(center)

  def calc_group(x,center):
    err=0
    group=[[] for _ in range(len(center))]
    for xi in x:
      dist=[]
      for c in center:
        dist.append(np.linalg.norm(xi-c))
      index=dist.index(min(dist))
      err+=min(dist)
      group[index].append(xi)
    return group,err/len(x)

  def label(x,center):
    label=[]
    for a in x:
      dist=[]
      for c in center:
        dist.append(np.linalg.norm(a-c))
      label.append(dist.index(min(dist)))
    return np.array(label)

  def calc_center(group):
    center=[]
    for g in group:
      center.append(np.mean(np.array(g),axis=0))
    return np.array(center)
  err=[]
  for n in range(itr):
    # assignment stage
    # write your code here
    group,error=calc_group(data,center)
    err.append(error)
    # re-estimation stage
    # write your code here
    center=calc_center(group) 
    #print(Cents)
    if n>2:
        if abs(err[n]-err[n-1])<eps:
          break

    print(n,end = '-->')
   
  return group, center,err,label(data,center)
